<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Kompletni Pedigree</title>
<style>
  :root{
    --brand:#90b038;
    --ink:#343434;
    --muted:#666;
    --card:#f7f7f7;
    --male:#52a6e6;
    --female:#e62aff;
    --shadow:0 2px 8px rgba(0,0,0,.1);

    --perView: 1;
    --slideDur: 280ms;
    --genGap: 20px;
  }
  @media (min-width:480px){ :root{ --perView: 2; } }
  @media (min-width:768px){ :root{ --perView: 3; } }
  @media (min-width:1280px){ :root{ --perView: 5; } }

  *{ box-sizing:border-box }
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:#f8f9fa; color:var(--ink);
  }

  #gen-5 .meta{ display:none; }
  #gen-5 img{  display:none; }

  /* Header + nav */
  .pedigree-header{
    position:sticky; top:0; z-index:20;
    background:var(--brand); color:#fff;
    display:flex; align-items:center; justify-content:center;
    padding:12px 16px;
  }
  .pedigree-header h1{margin:0; font-size:1rem; text-align:center}

  .nav{
    position:sticky; top:48px; z-index:19;
    background:rgba(255,255,255,.9); backdrop-filter: blur(6px);
    display:flex; align-items:center; justify-content:space-between;
    padding:10px 12px; border-bottom:1px solid #eaeaea;
  }
  .nav .title{font-weight:700}
  .nav .arrows{display:flex; gap:8px}
  .nav button{
    background:var(--brand); color:#fff; border:0; border-radius:8px;
    padding:8px 12px; cursor:pointer; font-size:16px
  }
  .nav button[disabled]{opacity:.5; cursor:not-allowed}

  /* Sticky generation titles */
  .generation-titles-bar{
    position: sticky;
    top: 88px; z-index: 18;
    background: rgba(255,255,255,.95);
    backdrop-filter: blur(6px);
    border-bottom: 1px solid #eaeaea;
    height: 50px; overflow: hidden;

    --pv: var(--perView);
    --gap: var(--genGap);
    --colW: calc((100% - (var(--gap) * (var(--pv) - 1))) / var(--pv));
  }
  .generation-titles-track{
    display:flex; align-items:center; gap: var(--gap);
    width: 100%;
    transition: transform var(--slideDur) ease;
    will-change: transform; box-sizing: border-box;
  }
  .gen-title{
    flex: 0 0 var(--colW);
    text-align: center; font-weight: 800; font-size: 0.9rem; color: var(--ink);
    padding: 12px 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }

  /* Slider */
  .slider{
    position:relative;
    overflow-x:hidden;
    overflow-y:visible;
    touch-action: pan-y; /* 1 prst scroll; 2 prsta – pinch (mi obrađujemo) */
  }

  /* Zumiramo samo ovaj sloj (sadrži track) */
  #zoomLayer{
    position: relative;
    transform-origin: 0 0;
    will-change: transform;
  }

  /* SVG OSTAVLJAMO VAN zoomLayer-a (ne skalira se) */
  .links-svg{
    position:absolute; inset:0; width:100%; height:100%;
    pointer-events:none; z-index:1; overflow:visible;
  }

  .track{
    position:relative; z-index:2;
    display:flex; align-items:flex-start;
    gap:var(--genGap);
    transition:transform var(--slideDur) ease;
    will-change:transform;
  }
  .slide{
    flex:0 0 calc((100% - (var(--genGap) * (var(--perView) - 1))) / var(--perView));
    padding:16px; overflow:visible;
    display:flex; flex-direction:column; align-items:stretch;
    position:relative; background:transparent;
  }

  .dog-col{ display:flex; flex-direction:column; gap:80px; position:relative; }

  .dog-card{
    background:var(--card); border-radius:10px; box-shadow:var(--shadow);
    padding:14px; display:flex; gap:12px; align-items:center;
    transform: translateY(0); will-change: transform;
    cursor: pointer; transition: background-color 0.2s ease;
  }
  .dog-card:hover { background: #f0f0f0; }
  .dog-card .img{
    width:84px; height:84px; border-radius:8px; background:#e5e5e5;
    object-fit:cover; flex:0 0 auto;
  }
  .dog-card .info{ min-width:0 }
  .dog-card .name{ font-weight:700; margin:0 0 4px }
  .dog-card .meta{ margin:0; color:#666; font-size:.9rem }

  .dog-card.male{   border-left:4px solid var(--male) }
  .dog-card.female{ border-left:4px solid var(--female) }

  .slide.gen-1 .dog-card,
  .slide.gen-2 .dog-card { flex-direction:column; text-align:center; align-items:center; }
  .slide.gen-3 .dog-card,
  .slide.gen-4 .dog-card,
  .slide.gen-5 .dog-card { flex-direction:row; text-align:left; align-items:center; }

  .slide.gen-4 .img, .slide.gen-5 .img{ width:48px; height:48px; }

  .slide.gen-4 .dog-card, .slide.gen-5 .dog-card{ padding:8px; gap:8px; }
  .slide.gen-4 .dog-card .name, .slide.gen-5 .dog-card .name{ font-size:0.85rem; margin-bottom:2px; }
  .slide.gen-4 .dog-card .meta, .slide.gen-5 .dog-card .meta{ font-size:0.75rem; }

  .slide.gen-1 .dog-card{ min-height:350px; }
  .slide.gen-2 .dog-card{ min-height:170px; }
  .slide.gen-3 .dog-card{ min-height:97px; }
  .slide.gen-4 .dog-card{ min-height:65px; }
  .slide.gen-5 .dog-card{ min-height:45px; }

  @media (min-width:1280px){
    .dog-card{ padding:10px; gap:8px; }
    .dog-card .img{ width:64px; height:64px; }
    .slide.gen-1 .img{ width:80px; height:80px; }
    .dog-card .name{ font-size:.95rem; }
    .dog-card .meta{ font-size:.78rem; }
    .slide.gen-4 .img, .slide.gen-5 .img{ display:none; }
    .slide.gen-5 .dog-card{ padding:4px; min-height:30px; }
    .slide.gen-5 .dog-card .name{ font-size:0.75rem; }
  }

  @media (prefers-reduced-motion:reduce){
    .track{ transition:none }
    .generation-titles-track{ transition:none }
  }
</style>
</head>
<body>
  <header class="pedigree-header">
    <h1 id="pedigreeTitle">Pedigree of Momo von Pallas Athene</h1>
  </header>

  <nav class="nav" aria-label="Pedigree navigation">
    <button id="prevBtn" title="Levo">‹</button>
    <div class="title" id="navTitle">1st Generation</div>
    <div class="arrows">
      <button id="nextBtn" title="Desno">›</button>
    </div>
  </nav>

  <div class="generation-titles-bar" id="generationTitlesBar">
    <div class="generation-titles-track" id="generationTitlesTrack">
      <div class="gen-title" data-gen="1">1st Generation</div>
      <div class="gen-title" data-gen="2">2nd Generation</div>
      <div class="gen-title" data-gen="3">3rd Generation</div>
      <div class="gen-title" data-gen="4">4th Generation</div>
      <div class="gen-title" data-gen="5">5th Generation</div>
    </div>
  </div>

  <section class="slider" id="slider" aria-live="polite">
    <!-- SVG OSTANE OVDE (nije u zoomLayer-u) -->
    <svg class="links-svg" id="linksSvg"></svg>
    <!-- Track ubacujemo u zoomLayer da bismo ga skalirali -->
    <div id="zoomLayer">
      <div class="track" id="track"></div>
    </div>
  </section>

<script>
(function(){
  /* ================= CONFIG ================= */
  const CFG = {
    gen: {
      1: { cardHeight: 350, pairGapDefault: 210, padTop: 40, padBottom: 0 },
      2: { cardHeight: 205, pairGapDefault: 102, padTop: 0, padBottom: 0 },
      3: { cardHeight:  97, pairGapDefault:  47, padTop: 0, padBottom: 0 },
      4: { cardHeight:  45, pairGapDefault:  22, padTop: 0, padBottom: 0 },
      5: { cardHeight:  20, pairGapDefault:   0, padTop: 0, padBottom: 0 }
    },
    pairGapOverrides: { },
    horizontalGap: { default: 20, tablet: 30, desktop: 40 }
  };

  const MALE_COLOR   = '#52a5e6';
  const FEMALE_COLOR = '#e62aff';
  const NEUTRAL_COLOR= '#b7bec5';
  const LINE_WIDTH   = 2.2;

  /* ================= DOM ================= */
  const track     = document.getElementById('track');
  const slider    = document.getElementById('slider');
  const linksSvg  = document.getElementById('linksSvg');
  const zoomLayer = document.getElementById('zoomLayer');

  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const navTitle= document.getElementById('navTitle');
  const pedigreeTitle = document.getElementById('pedigreeTitle');
  const generationTitlesTrack = document.getElementById('generationTitlesTrack');

  const titles = ['1st Generation','2nd Generation','3rd Generation','4th Generation','5th Generation'];

  let index = 0; let baseX = 0;

  /* ================= DATA ================= */
  let pedigreeData = {
    dogName: "Momo von Pallas Athene",
    gen1: { father: "Henry Latmon", mother: "Holly von Pallas Athene" },
    gen2: { ff: "Margman Yes", fm: "Ema Black Lehmburg", mf: "Nero von Ghattas", mm: "Xolly von Pallas Athene" },
    gen3: {
      fff: "Landos vom Quartier Latin", ffm: "Nika vom Nord Traum",
      fmf: "Bruno von Vierhundert Hertz", fmm: "Fest Kiefer Tashiba",
      mff: "Gary vom Hühnegrab", mfm: "Bella von Ghattas",
      mmf: "Kronos von Nürburgring", mmm: "Olivia von Pallas Athene"
    },
    gen4: {},
    gen5: {}
  };

  /* ============== ZOOM (samo slider sadrzaj) ============== */
  const Z = { scale:1, tx:0, ty:0, min:0.4, max:3, sens:0.75 };
  let suspendAlign = false; // ne recalculiši raspored tokom pinch/wheel

  const clamp = (v,min,max)=> Math.min(max, Math.max(min,v));
  const clampScale = s => clamp(s, Z.min, Z.max);

  function applyZoomTransform(animated=false){
    // ograniči ty da sadržaj ne “pobegne” gore/dole
    const unscaledH = zoomLayer.scrollHeight; // visina bez transform
    const scaledH   = unscaledH * Z.scale;
    const H = slider.clientHeight || slider.getBoundingClientRect().height;
    const minTy = Math.min(0, H - scaledH); // ako je sadržaj viši – dozvoli negativan pomak do donje ivice
    Z.ty = clamp(Z.ty, minTy, 0);

    const t = `translate(${Z.tx}px, ${Z.ty}px) scale(${Z.scale})`;
    if(animated){
      zoomLayer.style.transition = 'transform 160ms ease';
      requestAnimationFrame(()=>{ zoomLayer.style.transform = t; });
      setTimeout(()=>{ zoomLayer.style.transition = ''; }, 180);
    }else{
      zoomLayer.style.transform = t;
    }

    // slideru damo realnu “layout” visinu da bi stranica mogla da se skroluje
    slider.style.height = `${Math.max(scaledH, H)}px`;

    // linije prate i tokom zumiranja
    scheduleLinksRedraw();
  }
  function resetZoom(){ Z.scale=1; Z.tx=0; Z.ty=0; applyZoomTransform(true); }

  /* ============== UTILS ============== */
  const perView = ()=> {
    const v = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--perView')) || 1;
    return v >= 5 ? 5 : (v >= 3 ? 3 : (v >= 2 ? 2 : 1));
  };
  function maxIndex(){
    const total = track.children.length;
    return Math.max(0, total - perView());
  }
  function setTransform(percent, animate=true){
    track.style.transition = animate ? 'transform var(--slideDur) ease' : 'none';
    track.style.transform  = `translateX(${percent}%)`;

    if (generationTitlesTrack){
      generationTitlesTrack.style.transition = animate ? 'transform var(--slideDur) ease' : 'none';
      generationTitlesTrack.style.transform  = `translateX(${percent}%)`;
    }
    scheduleLinksRedraw();
  }
  function updateTitle(){
    const pv = perView();
    const total = titles.length;
    const leftIdx = index;
    const rightIdx = Math.min(index + pv - 1, total - 1);
    navTitle.textContent = (pv === 1)
      ? (titles[leftIdx] || `Generation ${leftIdx+1}`)
      : `${titles[leftIdx] || `Gen ${leftIdx+1}`} – ${titles[rightIdx] || `Gen ${rightIdx+1}`}`;
  }

  /* ============== RENDER ============== */
  function generateMissingGenerations() {
    const gen4Keys = ['ffff','fffm','ffmf','ffmm','fmff','fmfm','fmmf','fmmm','mfff','mffm','mfmf','mfmm','mmff','mmfm','mmmf','mmmm'];
    gen4Keys.forEach(key => { if (!pedigreeData.gen4[key]) pedigreeData.gen4[key] = 'Unknown'; });
    const gen5Keys = [];
    gen4Keys.forEach(gen4Key => { gen5Keys.push(gen4Key + 'F'); gen5Keys.push(gen4Key + 'M'); });
    gen5Keys.forEach(key => { if (!pedigreeData.gen5[key]) pedigreeData.gen5[key] = 'Unknown'; });
  }
  function getDefaultMeta(genNum){
    const metas = ['', 'Parent', 'Grandparent', 'Great-grandparent', 'Great-great-grandparent', 'Great-great-great-grandparent'];
    return metas[genNum] || 'Ancestor';
  }
  function createGeneration(genNum, dogs){
    const slide = document.createElement('div');
    slide.className = `slide gen-${genNum}`;
    slide.id = `gen-${genNum}`;
    let html = '<div class="dog-col">';
    dogs.forEach(dog=>{
      const sexClass = dog.sex === 'male' ? 'male' : 'female';
      const sexSymbol = dog.sex === 'male' ? '♂' : '♀';
      const displayName = `${dog.name} ${sexSymbol}`;
      const meta = dog.meta || getDefaultMeta(genNum);
      html += `
        <article class="dog-card ${sexClass}" id="card-${dog.id}" data-id="${dog.id}">
          <img class="img" src="#" alt="${displayName}" onerror="this.style.opacity=.25" />
          <div class="info">
            <p class="name">${displayName}</p>
            <p class="meta">${meta}</p>
          </div>
        </article>
      `;
    });
    html += '</div>';
    slide.innerHTML = html;
    return slide;
  }
  function generateDogsForGeneration(genNum){
    const dogs = [];
    if(genNum === 4){
      const keys = ['ffff','fffm','ffmf','ffmm','fmff','fmfm','fmmf','fmmm','mfff','mffm','mfmf','mfmm','mmff','mmfm','mmmf','mmmm'];
      keys.forEach((key,i)=> dogs.push({ id:key, name:pedigreeData.gen4[key]||'Unknown', sex:i%2===0?'male':'female' }));
    }else if(genNum === 5){
      const g4 = ['ffff','fffm','ffmf','ffmm','fmff','fmfm','fmmf','fmmm','mfff','mffm','mfmf','mfmm','mmff','mmfm','mmmf','mmmm'];
      g4.forEach(k=>{
        dogs.push({ id:k+'F', name:pedigreeData.gen5[k+'F']||'Unknown', sex:'male' });
        dogs.push({ id:k+'M', name:pedigreeData.gen5[k+'M']||'Unknown', sex:'female' });
      });
    }
    return dogs;
  }
  function generatePedigreeHTML(){
    track.innerHTML = '';
    generateMissingGenerations();
    track.appendChild(createGeneration(1, [
      {id:'father', name:pedigreeData.gen1.father, sex:'male',   meta:'Father'},
      {id:'mother', name:pedigreeData.gen1.mother, sex:'female', meta:'Mother'}
    ]));
    track.appendChild(createGeneration(2, [
      {id:'ff', name:pedigreeData.gen2.ff, sex:'male',   meta:'Paternal Grandfather'},
      {id:'fm', name:pedigreeData.gen2.fm, sex:'female', meta:'Paternal Grandmother'},
      {id:'mf', name:pedigreeData.gen2.mf, sex:'male',   meta:'Maternal Grandfather'},
      {id:'mm', name:pedigreeData.gen2.mm, sex:'female', meta:'Maternal Grandmother'}
    ]));
    track.appendChild(createGeneration(3, [
      {id:'fff', name:pedigreeData.gen3.fff, sex:'male'},
      {id:'ffm', name:pedigreeData.gen3.ffm, sex:'female'},
      {id:'fmf', name:pedigreeData.gen3.fmf, sex:'male'},
      {id:'fmm', name:pedigreeData.gen3.fmm, sex:'female'},
      {id:'mff', name:pedigreeData.gen3.mff, sex:'male'},
      {id:'mfm', name:pedigreeData.gen3.mfm, sex:'female'},
      {id:'mmf', name:pedigreeData.gen3.mmf, sex:'male'},
      {id:'mmm', name:pedigreeData.gen3.mmm, sex:'female'}
    ]));
    track.appendChild(createGeneration(4, generateDogsForGeneration(4)));
    track.appendChild(createGeneration(5, generateDogsForGeneration(5)));
    pedigreeTitle.textContent = `Pedigree of ${pedigreeData.dogName}`;
  }

  /* ============== LINKOVI (EKRANSKE KOORDINATE) ============== */
  function getSidePoint(el, side){
    const r = el.getBoundingClientRect();
    const S = slider.getBoundingClientRect();
    const x = (side==='left') ? (r.left - S.left) : (r.right - S.left);
    const y = (r.top - S.top) + r.height/2;
    return {x,y};
  }
  const colorFor = sex => sex==='male'?MALE_COLOR : (sex==='female'?FEMALE_COLOR:NEUTRAL_COLOR);
  function getSex(el){
    if(!el) return 'unknown';
    if(el.classList.contains('male')) return 'male';
    if(el.classList.contains('female')) return 'female';
    const txt = (el.textContent||'').toLowerCase();
    if(txt.includes('♂')) return 'male';
    if(txt.includes('♀')) return 'female';
    return 'unknown';
  }
  function clearLinks(){ while(linksSvg.firstChild) linksSvg.removeChild(linksSvg.firstChild); }
  function makePath(d, stroke){
    const p = document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('d', d); p.setAttribute('fill','none'); p.setAttribute('stroke', stroke);
    p.setAttribute('stroke-width', LINE_WIDTH); p.setAttribute('stroke-linecap','round'); p.setAttribute('stroke-linejoin','round');
    return p;
  }
  function cubicPath(x1,y1,x2,y2){
    const dx = Math.max(20, Math.abs(x2-x1)/2);
    return `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`;
  }
  function getLinks(){
    return {
      father:['ff','fm'], mother:['mf','mm'],
      ff:['fff','ffm'], fm:['fmf','fmm'], mf:['mff','mfm'], mm:['mmf','mmm'],
      fff:['ffff','fffm'], ffm:['ffmf','ffmm'], fmf:['fmff','fmfm'], fmm:['fmmf','fmmm'],
      mff:['mfff','mffm'], mfm:['mfmf','mfmm'], mmf:['mmff','mmfm'], mmm:['mmmf','mmmm'],
      ffff:['ffffF','ffffM'], fffm:['fffmF','fffmM'], ffmf:['ffmfF','ffmfM'], ffmm:['ffmmF','ffmmM'],
      fmff:['fmffF','fmffM'], fmfm:['fmfmF','fmfmM'], fmmf:['fmmfF','fmmfM'], fmmm:['fmmmF','fmmmM'],
      mfff:['mfffF','mfffM'], mffm:['mffmF','mffmM'], mfmf:['mfmfF','mfmfM'], mfmm:['mfmmF','mfmmM'],
      mmff:['mmffF','mmffM'], mmfm:['mmfmF','mmfmM'], mmmf:['mmmfF','mmmfM'], mmmm:['mmmmF','mmmmM']
    };
  }

  let linksRAF = 0, transAnimating = false;
  function scheduleLinksRedraw(){
    if(linksRAF) return;
    linksRAF = requestAnimationFrame(()=>{ linksRAF = 0; drawLinks(); });
  }
  function animateLinksDuringTransition(){
    if(!transAnimating) return;
    drawLinks();
    requestAnimationFrame(animateLinksDuringTransition);
  }
  function drawLinks(){
    clearLinks();
    const W = slider.clientWidth;
    const H = slider.clientHeight; // slider već ima visinu ~ scaled content
    linksSvg.setAttribute('width', W);
    linksSvg.setAttribute('height', H);
    linksSvg.setAttribute('viewBox', `0 0 ${W} ${H}`);

    const map = getLinks();
    Object.entries(map).forEach(([parentId, kidsIds])=>{
      const parent = document.getElementById('card-'+parentId);
      const kids = (kidsIds||[]).map(id=>document.getElementById('card-'+id)).filter(Boolean);
      if(!parent || kids.length<2) return;

      const parentColor = colorFor(getSex(parent));
      const start = getSidePoint(parent, 'right');
      const ends  = kids.map(k => getSidePoint(k, 'left'));

      const minEndX = Math.min(ends[0].x, ends[1].x);
      const branchX = Math.min(start.x + 40, minEndX - 12);
      const branchY = start.y;

      linksSvg.appendChild(makePath(cubicPath(start.x, branchY, branchX, branchY), parentColor));
      kids.forEach((kid, idx)=>{
        const end = ends[idx];
        linksSvg.appendChild(makePath(cubicPath(branchX, branchY, end.x, end.y), colorFor(getSex(kid))));
      });
    });
  }

  /* ======= PORAVNANJE ======= */
  function centerYAbs(el){ const r = el.getBoundingClientRect(); return r.top + r.height/2; }
  function getGenNumberForCard(cardEl){
    const slide = cardEl.closest('.slide'); if(!slide) return null;
    const m = /gen-(\d+)/.exec(slide.id); return m ? Number(m[1]) : null;
  }
  function alignChildrenToParent(parentId, childIds){
    const parent = document.getElementById('card-'+parentId); if(!parent) return;
    const kids = childIds.map(id=>document.getElementById('card-'+id)).filter(Boolean); if(kids.length<2) return;

    const parentC = centerYAbs(parent);
    let [k1,k2] = kids;
    let c1 = centerYAbs(k1), c2 = centerYAbs(k2);

    let topKid, botKid, cTop, cBot;
    if(c1<=c2){ topKid=k1; botKid=k2; cTop=c1; cBot=c2; } else { topKid=k2; botKid=k1; cTop=c2; cBot=c1; }

    const baseTop = Number(topKid.dataset.offset||0);
    const baseBot = Number(botKid.dataset.offset||0);

    const parentGen = getGenNumberForCard(parent);
    let desiredGapPx = (CFG.pairGapOverrides && Object.prototype.hasOwnProperty.call(CFG.pairGapOverrides,parentId))
      ? CFG.pairGapOverrides[parentId]
      : (CFG.gen[parentGen]?.pairGapDefault ?? null);

    if(typeof desiredGapPx==='number'){
      const half = desiredGapPx/2;
      const targetTop = parentC - half;
      const targetBot = parentC + half;

      const deltaTop = targetTop - cTop;
      const deltaBot = targetBot - cBot;

      // kompenzuj skaliranje: translateY je u content prostoru, a delta je u ekranskim pikselima
      const scale = Z.scale || 1;
      topKid.style.transform = `translateY(${baseTop + Math.round(deltaTop / scale)}px)`;
      botKid.style.transform = `translateY(${baseBot + Math.round(deltaBot / scale)}px)`;
    }else{
      const mid = (cTop + cBot)/2;
      const delta = (parentC - mid);
      const scale = Z.scale || 1;
      topKid.style.transform = `translateY(${baseTop + Math.round(delta / scale)}px)`;
      botKid.style.transform = `translateY(${baseBot + Math.round(delta / scale)}px)`;
    }
  }
  function padSlideForTransforms(slide){
    // dopuni padding da ništa ne iseče (računamo po ekranu)
    const cards = slide.querySelectorAll('.dog-card'); if(!cards.length) return;
    let topMin = Infinity, botMax = -Infinity;
    cards.forEach(c=>{ const r=c.getBoundingClientRect(); if(r.top<topMin) topMin=r.top; if(r.bottom>botMax) botMax=r.bottom; });
    const sRect = slide.getBoundingClientRect();
    const needTop = Math.max(0, sRect.top - topMin + 8);
    const needBot = Math.max(0, botMax - sRect.bottom + 8);

    const baseTop = 16 + (CFG.gen[Number(slide.id.replace('gen-',''))]?.padTop||0);
    const baseBot = 16 + (CFG.gen[Number(slide.id.replace('gen-',''))]?.padBottom||0);
    // kompenzuj skaliranje: padding se primenjuje u content prostoru
    const scale = Z.scale || 1;
    slide.style.paddingTop    = `${baseTop + Math.round(needTop / scale)}px`;
    slide.style.paddingBottom = `${baseBot + Math.round(needBot / scale)}px`;
  }
  function applyGenerationStylingFromCFG(){
    Object.entries(CFG.gen).forEach(([g, conf])=>{
      const slide = document.getElementById(`gen-${g}`); if(!slide) return;
      const baseTop = 16 + (conf.padTop||0);
      const baseBot = 16 + (conf.padBottom||0);
      slide.style.paddingTop    = `${baseTop}px`;
      slide.style.paddingBottom = `${baseBot}px`;
      slide.querySelectorAll('.dog-card').forEach(card=>{
        if(conf.cardHeight){
          card.style.height = `${conf.cardHeight}px`;
          card.style.minHeight = `${conf.cardHeight}px`;
        }else{
          card.style.height = ''; card.style.minHeight = '';
        }
      });
    });
  }
  function alignAll(){
    if(suspendAlign) { scheduleLinksRedraw(); return; }
    applyGenerationStylingFromCFG();
    document.querySelectorAll('.dog-card').forEach(c=>{
      const off = Number(c.dataset.offset||0);
      c.style.transform = `translateY(${off}px)`;
    });
    const links = getLinks();
    [1,2,3,4].forEach(g=>{
      document.querySelectorAll(`#gen-${g} .dog-card`).forEach(card=>{
        const id = card.dataset.id; if(id && links[id]) alignChildrenToParent(id, links[id]);
      });
    });
    document.querySelectorAll('.slide').forEach(padSlideForTransforms);
    drawLinks();
  }

  /* ============ NAV ============ */
  function applyHorizontalGapFromCFG(){
    let g = CFG.horizontalGap.default ?? 20;
    const w = window.innerWidth;
    if(w >= 1280 && CFG.horizontalGap.desktop !== undefined) g = CFG.horizontalGap.desktop;
    else if(w >= 768 && CFG.horizontalGap.tablet !== undefined) g = CFG.horizontalGap.tablet;
    document.documentElement.style.setProperty('--genGap', g + 'px');
  }
  function sync(){
    applyHorizontalGapFromCFG();
    const pv = perView();
    index = Math.max(0, Math.min(index, maxIndex()));
    const stepPercent = 100 / pv;
    baseX = -(index * stepPercent);
    setTransform(baseX, true);

    const atOverview = (pv === 5);
    prevBtn.disabled = atOverview || (index === 0);
    nextBtn.disabled = atOverview || (index >= maxIndex());

    updateTitle();
    applyZoomTransform(false);
    requestAnimationFrame(()=> alignAll());
  }
  function goNext(){ if(index < maxIndex()){ index += 1; } resetZoom(); sync(); }
  function goPrev(){ if(index > 0){ index -= 1; } resetZoom(); sync(); }

  prevBtn.addEventListener('click', goPrev);
  nextBtn.addEventListener('click', goNext);

  /* ============ GESTURE: drag + pinch ============ */
  const pointers = new Map();
  let pinchActive = false, pinchStartDist = 0, pinchStartScale = 1;
  let dragCandidate = false, dragStarted = false;
  let startX = 0, startY = 0, dxPct = 0;
  const dist = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);

  slider.addEventListener('pointerdown', (e)=>{
    pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

    if(pointers.size === 2){
      pinchActive = true; suspendAlign = true;
      const [p1,p2] = [...pointers.values()];
      pinchStartDist = dist(p1,p2);
      pinchStartScale = Z.scale;
    }else if(pointers.size === 1){
      dragCandidate = true; dragStarted = false;
      startX = e.clientX; startY = e.clientY; dxPct = 0;
    }
  }, {passive:true});

  slider.addEventListener('pointermove', (e)=>{
    if(pointers.has(e.pointerId)){ const cur=pointers.get(e.pointerId); cur.x=e.clientX; cur.y=e.clientY; }

    if(pinchActive && pointers.size>=2){
      e.preventDefault();
      const [p1,p2] = [...pointers.values()];
      const curDist = dist(p1,p2);
      const raw = curDist / Math.max(1, pinchStartDist);
      const newScale = clampScale(pinchStartScale * Math.pow(raw, Z.sens));

      // fokus na sredini prstiju
      const Srect = slider.getBoundingClientRect();
      const fx = ((p1.x+p2.x)/2) - Srect.left - Z.tx;
      const fy = ((p1.y+p2.y)/2) - Srect.top  - Z.ty;

      const prev = Z.scale;
      Z.scale = newScale;
      Z.tx -= (fx * (Z.scale/prev - 1));
      Z.ty -= (fy * (Z.scale/prev - 1));

      applyZoomTransform(false);
      return;
    }

    if(dragCandidate && !dragStarted){
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      if(Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 8){ dragCandidate=false; return; }
      if(Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 8){
        dragStarted = true;
      }
    }

    if(dragStarted){
      const mx = e.clientX - startX;
      dxPct = (mx / slider.clientWidth) * 100;

      const pv = perView();
      const stepPercent = 100 / pv;
      const leftLimit   = 0;
      const rightLimit  = -maxIndex()*stepPercent;
      const candidate   = baseX + dxPct;

      const clamped     = Math.max(rightLimit - 10, Math.min(leftLimit + 10, candidate));
      setTransform(clamped, false);
    }
  }, {passive:false});

  function finishPointer(e){
    pointers.delete(e.pointerId);

    if(pinchActive && pointers.size < 2){
      pinchActive = false;
      suspendAlign = false;
      applyZoomTransform(false);
      alignAll(); // jedno poravnanje na kraju pinch-a
      return;
    }

    if(!dragCandidate && !dragStarted) return;

    const threshold = 18;
    if(dragStarted){
      if(Math.abs(dxPct) > threshold){ if(dxPct < 0) goNext(); else goPrev(); }
      else{ setTransform(baseX, true); }
    }
    dragCandidate = false; dragStarted = false; dxPct = 0;
  }
  slider.addEventListener('pointerup', finishPointer, {passive:true});
  slider.addEventListener('pointercancel', finishPointer, {passive:true});
  slider.addEventListener('pointerleave', finishPointer, {passive:true});

  // desktop ctrl+wheel zoom (sa malim debounce-om za align)
  let wheelAlignTO = null;
  slider.addEventListener('wheel', (e)=>{
    if(!e.ctrlKey) return;
    e.preventDefault();
    suspendAlign = true;

    const factor = Math.pow(1.0015, -e.deltaY) ** Z.sens;
    const Srect = slider.getBoundingClientRect();
    const fx = e.clientX - Srect.left - Z.tx;
    const fy = e.clientY - Srect.top  - Z.ty;

    const prev = Z.scale;
    Z.scale = clampScale(prev * factor);
    Z.tx -= (fx * (Z.scale/prev - 1));
    Z.ty -= (fy * (Z.scale/prev - 1));
    applyZoomTransform(false);

    clearTimeout(wheelAlignTO);
    wheelAlignTO = setTimeout(()=>{ suspendAlign=false; alignAll(); }, 120);
  }, { passive:false });

  /* ============ TRANSITION: animiraj linije tokom klizanja ============ */
  track.addEventListener('transitionstart', ()=>{
    transAnimating = true;
    animateLinksDuringTransition();
  });
  track.addEventListener('transitionend', ()=>{
    transAnimating = false;
    drawLinks();
  });

  /* ============ INIT/SYNC ============ */
  function applyHorizontalGapFromCFG(){
    let g = CFG.horizontalGap.default ?? 20;
    const w = window.innerWidth;
    if(w >= 1280 && CFG.horizontalGap.desktop !== undefined) g = CFG.horizontalGap.desktop;
    else if(w >= 768 && CFG.horizontalGap.tablet !== undefined) g = CFG.horizontalGap.tablet;
    document.documentElement.style.setProperty('--genGap', g + 'px');
  }
  function sync(){
    applyHorizontalGapFromCFG();
    const pv = perView();
    index = Math.max(0, Math.min(index, maxIndex()));
    const stepPercent = 100 / pv;
    baseX = -(index * stepPercent);
    setTransform(baseX, true);

    const atOverview = (pv === 5);
    prevBtn.disabled = atOverview || (index === 0);
    nextBtn.disabled = atOverview || (index >= maxIndex());

    updateTitle();
    applyZoomTransform(false);
    requestAnimationFrame(()=> alignAll());
  }

  function goNext(){ if(index < maxIndex()){ index += 1; } resetZoom(); sync(); }
  function goPrev(){ if(index > 0){ index -= 1; } resetZoom(); sync(); }

  prevBtn.addEventListener('click', goPrev);
  nextBtn.addEventListener('click', goNext);

  // Resize — ne radi align tokom pinch/wheel
  if (window.ResizeObserver) {
    const ro = new ResizeObserver(() => {
      if(suspendAlign) return;
      requestAnimationFrame(() => { applyZoomTransform(false); alignAll(); });
    });
    ro.observe(slider);
  }
  window.addEventListener('resize', ()=>{ if(!suspendAlign){ applyZoomTransform(false); sync(); } });

  // Init
  window.addEventListener('load', ()=>{ 
    generatePedigreeHTML();
    applyZoomTransform(false);
    setTimeout(()=>{ sync(); }, 0);
  });

  // debug
  window.realign = ()=> requestAnimationFrame(()=> alignAll());
})();
</script>
</body>
</html>
